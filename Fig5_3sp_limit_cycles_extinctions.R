###############################################################################
### Figure 5 - Dynamic transitions and extinctions in 3 species RPS model #####
###############################################################################

# Nick Lowery and Tristan Ursell
# 2018
# 
# This script generates Figure 5 from our preprint:
# Structured environments fundamentally alter dynamics and stability of ecological communities
# https://www.biorxiv.org/content/early/2018/07/10/366559
# 
# The script reads in metadata and autocorrelation data files, as generated by
# the LV_competition_function.m and autocorrelation_analysis.m MATLAB functions.  Code
# used to generate the cleaned autocorrelation data is included below but commented out.
# This script analyzes the autocorrelation matrix, and classifies when it shows limit
# cycle dynamics (see SI in the paper for more explanation on this).  It then generates
# a pair of heatmaps showing the time spent in a limit cycle (relative to the non-pillar
# controls) and the frequency of extinction events among replicates.

###############################################################################

library(tidyverse)
library(pracma)
library(cowplot)
library(colorspace)

# # list autocorrelation data files
# acf.files <- data.frame(files = list.files("E:/ecological_modelling/3sp_acf", full.names = T)) %>%
#   filter(str_detect(files, "P-0.1")) %>%
#   mutate(files = as.character(files))
# 
# # extract simulation parameters
# acf.params <- acf.files$files %>% {
#   tibble(
#     P = map_dbl(., function(x) as.numeric(stri_match(x, regex = "P-(.+?)_")[,2])),
#     pillars = map_dbl(., function(x) as.numeric(stri_match(x, regex = "pillars-(\\d+?)_")[,2])),
#     R = map_dbl(., function(x) as.numeric(stri_match(x, regex = "R-(\\d+?)_")[,2])),
#     dx = map_dbl(., function(x) as.numeric(stri_match(x, regex = "dx-(\\d+?)_")[,2])),
#     rep = map_dbl(., function(x) as.numeric(stri_match(x, regex = "rep-(\\d+?)_")[,2]))
#   )
# }
# 
# # read in data files, organize into tbl (~6 GB, takes a while)
# acf.params <- acf.params %>% mutate(data = lapply(acf.files$files, read.csv, header = F)) %>% unnest()
# 
# # write to disk
# write_csv(acf.params, "E:/ecological_modelling/3sp_acf_cleaned_data.csv")

###############################################################################
### read in and organize data #################################################
###############################################################################

# read in cleaned autocorrelation data (~5.5 GB, fair warning)
acf.df <- data.table::fread("E:/ecological_modelling/3sp_acf_cleaned_data.csv") %>%
  nest(starts_with("V"))

# read in cleaned abundance data
  # note that converting back and forth between numeric and factor types for R and dx
  # is necessary to facilitate calculations and joins, respectfully.
metadata.3sp <- read_csv("E:/ecological_modelling/3sp_metadata_filt.csv") %>%
  mutate(t.step = round(t.step, digits = 1),
         R = as.factor(R),
         dx = as.factor(dx)) %>%
  filter(t.step %% 1 == 0)

pillar.weights <- read_csv("E:/ecological_modelling/filt_all_weights.csv", 
                           col_names = c("L","R","dx","pillar.weight")) %>%
  mutate(dx = as.factor(R*dx),
         R = as.factor(R))

metadata <- left_join(metadata.3sp, pillar.weights) %>%
  # rename each of three species for convenience
  rename(A = meanA, B = meanB, C = meanC) %>%
  # calculate extinction events, accounting for 'trapped' areas between pillar and edge of simulation
  mutate(R = as.numeric(levels(R))[R],
         dx = as.numeric(levels(dx))[dx],
         extinct = ifelse(A <= ((2*R)^2 - pi*R^2)/4/pillar.weight |  
                          B <= ((2*R)^2 - pi*R^2)/4/pillar.weight |
                          C <= ((2*R)^2 - pi*R^2)/4/pillar.weight , 1, 0),
         R = as.factor(R),
         dx = as.factor(dx)) %>%
  # nest to simplify following join
  nest(A, B, C, t.step, extinct, .key = "metadata")


# join autocorrelation and metadata into final tbl
acf.full <- acf.df %>%
  mutate(R = as.factor(R),
         dx = as.factor(dx)) %>%
  left_join(., metadata)

###############################################################################
### classify dynamics based on autocorrelations ###############################
###############################################################################

# peak detection: for acf, returns 1 if >= 2 peaks above threshold for window size 2 * half.window
  # threshold of 0.9 too high; no-pillar cases oscillating in and out of cycles
can_haz_peaks <- function(x, half.window = 5, threshold = 0.8) {
  peaks <- findpeaks(x, nups = half.window, minpeakheight = threshold)
  if(isempty(peaks) || nrow(peaks) < 2) return(0) else return(1)
}

# initialize output variable (list-column)
acf.full$is.cycle <- vector("list", length = nrow(acf.full))

# map peak and transition detections across all simulations
for (i in 1:nrow(acf.full)) {
  # pull out autocorrelation matrix
  tempmat <- as.matrix(acf.full$data[[i]])
  # initialize list for each row of matrix (list, because they'll all have different lengths)
  templist <- vector("list", length = nrow(tempmat))
  # loop through each row, taking only entries from diagonal to edge
  for(j in 1:nrow(tempmat)) {
    templist[[j]] <- tempmat[j:nrow(tempmat), j]
  }
  # run peak detection on each row
  has.peaks <- unlist(map(templist, ~ can_haz_peaks(.)))
  # return is.cycle vector to list column
  acf.full$is.cycle[[i]] <- has.peaks
  # print progress report
  if (i %% 50 == 0) print(paste("Finished iteration", i, "of", nrow(acf.full)))
}

###############################################################################
### construct figure ##########################################################
###############################################################################

# create color palette (function generated from colorspace GUI)
pal2 <- function (n, h = c(300, 75), c. = c(35, 95), l = c(15, 90), 
                  power = c(0.8, 1.2), fixup = TRUE, gamma = NULL, alpha = 1, 
                  ...) 
{
  if (!is.null(gamma)) 
    warning("'gamma' is deprecated and has no effect")
  if (n < 1L) 
    return(character(0L))
  h <- rep(h, length.out = 2L)
  c <- rep(c., length.out = 2L)
  l <- rep(l, length.out = 2L)
  power <- rep(power, length.out = 2L)
  rval <- seq(1, 0, length = n)
  rval <- hex(polarLUV(L = l[2L] - diff(l) * rval^power[2L], 
                       C = c[2L] - diff(c) * rval^power[1L], H = h[2L] - diff(h) * 
                         rval), fixup = fixup, ...)
  if (!missing(alpha)) {
    alpha <- pmax(pmin(alpha, 1), 0)
    alpha <- format(as.hexmode(round(alpha * 255 + 1e-04)), 
                    width = 2L, upper.case = TRUE)
    rval <- paste(rval, alpha, sep = "")
  }
  return(rval)
}

# proportion of time in limit cycle, scaled to no pillar case
acf.dyn <- acf.full %>%
  # get relevant columns
  select(P:rep, is.cycle) %>%
  # remove case where pillars are too dense for sim to function properly
  filter(!(R == 10 & dx == 22)) %>%
  unnest() %>%
  # wrangling to make heatmaps look nice
  mutate(dx_mult = ifelse(as.numeric(levels(R))[R] > 0, as.numeric(levels(dx))[dx] / as.numeric(levels(R))[R], 0),
         R = round(as.numeric(levels(R))[R]/sqrt(15), digits = 2),
         R = fct_relevel(as.factor(R), "0", after = Inf),
         dx_mult = fct_relevel(as.factor(dx_mult), "0", after = Inf)) %>%
  # calculate relative time in cycle
  group_by(R, dx_mult, rep) %>%
  summarise(cyclic = sum(is.cycle)/n()) %>%
  group_by(R, dx_mult) %>%
  summarise(cyclic = mean(cyclic)) %>%
  ungroup() %>%
  mutate(rel.cyclic = cyclic / max(cyclic))

# generate heatmap (a.k.a. phase plot)
dyn.phase <- acf.dyn %>%
  ggplot(aes(x = dx_mult, y = R, fill = rel.cyclic)) +
  geom_tile() +
  scale_fill_gradientn(colors = pal2(7)) +
  scale_x_discrete(labels = c(2.2,"","","",3,"","","","",4,"","","","",5,"Inf")) +
  labs(x = "pillar spacing (dx/R)", 
       y = expression(paste("pillar radius ( R / ", lambda, ")")), 
       fill = paste("relative", "time in", "limit cycle", "", sep = "\n")) +
  theme(panel.background = element_rect(fill = "grey80"), 
        legend.position = c(1,0.525),
        plot.margin = unit(c(0.1,1,0.1,0.1), "inch"))
dyn.phase


# extinction as a function of environmental structure, following same schema as above
acf.ext <- acf.full %>%
  select(P:rep, metadata) %>%
  filter(!(R == 10 & dx == 22)) %>%
  mutate(dx_mult = ifelse(as.numeric(levels(R))[R] > 0, as.numeric(levels(dx))[dx] / as.numeric(levels(R))[R], 0),
         R = round(as.numeric(levels(R))[R]/sqrt(15), digits = 2),
         R = fct_relevel(as.factor(R), "0", after = Inf),
         dx_mult = fct_relevel(as.factor(dx_mult), "0", after = Inf)) %>%
  unnest() %>%
  group_by(R, dx_mult, rep) %>%
  summarise(extinction = max(extinct)) %>%
  group_by(R, dx_mult) %>%
  summarise(prop.extinct = sum(extinction)/n()) 

# generate plot
ext.phase <- acf.ext %>%
  ggplot(aes(x = dx_mult, y = R, fill = prop.extinct)) +
  geom_tile() +
  scale_fill_gradientn(colors = pal2(7)) +
  scale_x_discrete(labels = c(2.2,"","","",3,"","","","",4,"","","","",5,"Inf")) +
  labs(x = "pillar spacing (dx/R)", 
       y = expression(paste("pillar radius ( R / ", lambda, ")")), 
       fill = paste("extinction", "frequency", "", sep = "\n")) +
  theme(panel.background = element_rect(fill = "grey80"), 
        legend.position = c(1,0.5),
        plot.margin = unit(c(0.1,1,0.1,0.1), "inch"))

# final figure
plot_grid(dyn.phase, ext.phase, labels = "AUTO", label_size = 24)
